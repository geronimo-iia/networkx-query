{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"networkx-query","text":"<p>Versions following Semantic Versioning</p>"},{"location":"#overview","title":"Overview","text":"<p>NetworkX Query Tool</p> <p>See documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install this library directly into an activated virtual environment:</p> <pre><code>$ pip install networkx-query\n</code></pre> <p>or add it to your Poetry project:</p> <pre><code>$ poetry add networkx-query\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#searching-nodes","title":"Searching nodes","text":"<pre><code>import networkx as nx\nfrom networkx_query import search_nodes, search_edges\n\ng = nx.DiGraph()\ng.add_node(1, product=\"chocolate\")\ng.add_node(2, product=\"milk\")\ng.add_node(3, product=\"coat\")\ng.add_edge(1, 2, action=\"shake\")\ng.add_edge(3, 2, action=\"produce\")\n\n\nfor node_id in search_nodes(g, {\"==\": [(\"product\",), \"chocolate\"]}):\n    print(node_id)\n\n&gt;&gt; 1\n</code></pre>"},{"location":"#searching-edges","title":"Searching edges","text":"<pre><code>for edge_id in search_edges(g, {\"eq\": [(\"action\",), \"produce\"]}):\n    print(edge_id)\n\n&gt;&gt; (3, 2)\n</code></pre>"},{"location":"#searching-direct-relation-ship","title":"Searching direct relation ship","text":"<p>With <code>search_direct_relationships</code> you can made a query which filter edges on their :  - source node attributes  - edge attributes  - target node attributes</p> <p>With this graph:</p> <pre><code>import networkx as nx\nfrom networkx_query import search_direct_relationships\n\ng = nx.DiGraph()\nfor i in range(30):\n    g.add_node(i, data=i)\n\nfor i in range(10, 30):\n    g.add_edge(i - 10, i, data=i)\n</code></pre> <p>We can filtering all edges with source node with data &lt; 3:</p> <pre><code>list(search_direct_relationships(graph=g, source={\"lt\": [\"data\", 3]}))\n\n[(0, 10), (1, 11), (2, 12)]\n</code></pre> <p>We can filtering all edges with:  - source node with data &lt; 8  - edge with data &gt; 15</p> <pre><code>list(search_direct_relationships(graph=g, source={\"lt\": [\"data\", 8]}, edge={\"gt\": [\"data\", 15]}))\n\n&gt;&gt; [(6, 16), (7, 17)]\n</code></pre> <p>We can filtering all edges with:  - source node with data &gt; 9  - edge with data &gt; 15  - target node with data &lt; 22</p> <pre><code>search_direct_relationships(\n            graph=g, source={\"gt\": [\"data\", 9]}, edge={\"gt\": [\"data\", 15]}, target={'lt': [\"data\", 22]}\n        )\n    )\n\n&gt;&gt; [(10, 20), (11, 21)]\n</code></pre>"},{"location":"#search_relationships","title":"search_relationships","text":"<p>With :</p> <pre><code>    g = nx.DiGraph()\n    g.add_node(1, product=\"a\")\n    g.add_node(2, product=\"b\")\n    g.add_node(3, product=\"c\")\n    g.add_node(4, product=\"d\")\n\n    g.add_edge(1, 2)\n    g.add_edge(1, 3, weight=2)\n    g.add_edge(1, 4)\n\n    g.add_edge(2, 4)\n    g.add_edge(3, 4)\n</code></pre> <p>You could find all path with multiple constraints:</p> <pre><code>    list(search_relationships(\n            g,\n            {\"eq\": [(\"product\",), \"a\"]},\n            PathCriteria(target={\"eq\": [(\"product\",), \"b\"]}),\n            PathCriteria(target={\"eq\": [(\"product\",), \"d\"]}),\n        )) \n    # output: [[1, 2, 4]]\n\n     list(search_relationships(g, {\"eq\": [(\"product\",), \"a\"]}, PathCriteria(target={\"eq\": [(\"product\",), \"c\"]})))\n     # outptu: [[1, 3]]\n</code></pre> <p>or something more complex:</p> <pre><code>\n    g.add_node(5, product=\"d\")\n    g.add_node(6, product=\"d\")\n    g.add_node(7, product=\"a\")\n    g.add_node(8, product=\"a\")\n\n    g.add_edge(7, 5, weight=2)\n    g.add_edge(7, 6, weight=2)\n    g.add_edge(8, 5, weight=2)\n\n    list(\n        search_relationships(\n            g,\n            {\"eq\": [(\"product\",), \"a\"]},  # node 1, 7, 8\n            PathCriteria(\n                target={\"eq\": [(\"product\",), \"d\"]}, edge={\"eq\": [(\"weight\",), 2]}\n            ),  # edge 1-3, 7-5, 7-6, 8-5  node 4, 5, 6 -&gt; no 1, 3, 4\n        )\n    )\n    # output: [[7, 5], [7, 6], [8, 5]]\n\n    list(\n        search_relationships(\n            g,\n            {\"eq\": [(\"product\",), \"a\"]},  # node 1, 7, 8\n            PathCriteria(target={}, edge={\"eq\": [(\"weight\",), 2]}),  # edge 1-3, 7-5, 7-6, 8-5\n            PathCriteria(target={\"eq\": [(\"product\",), \"d\"]}),  # node 4, 5, 6 -&gt; no 1, 3, 4\n        )\n    )\n    # output: [[1, 3, 4]]\n</code></pre> <p>Note the usage of <code>PathCriteria(target={}, ..</code> to define a constraint based only on edge. <code>{}</code> act as a wildcard.</p>"},{"location":"#api","title":"API","text":"<p>Actually, we have:</p> <ul> <li>search_edges</li> <li>search_nodes </li> <li>search_direct_relationships </li> <li>search_relationships </li> </ul> <p>All this function are based on prepare_query which return an Evaluator.</p> <p>Quickly, <code>Evaluator</code> are function with this signature: (context) -&gt; bool, and <code>Context</code> is a dictionary like structure (with in and [] methods, and support contains or  (iter and getitem)) With networkX, node and edge attributes are dictionary like, so implementation of this three methods are very simple.</p>"},{"location":"#query-language","title":"Query language","text":"<p>We define a little json query language like json-query-language  against nodes or edges attributes.</p>"},{"location":"#expressions","title":"Expressions","text":"<p>Main expression syntax turn around this:</p> <pre><code>{\n    operator_name : parameters\n}\n</code></pre>"},{"location":"#basic-matching-expression","title":"Basic matching expression","text":"<p>Test if a node/edge has an attribute named \"my_property\":</p> <pre><code>{\n    \"has\" : \"my_property\"\n}\n</code></pre> <p>Test if a node/edge has an attribute product : { \"definition\": { \"name\": xxx }} with xxx equals to \"chocolate\".</p> <pre><code>{\n    \"eq\" : [ (\"product\", \"definition\", \"name\"), \"chocolate\"]\n}\n</code></pre> <p>The tuple <code>(\"product\", \"definition\", \"name\")</code> is a path in attribut dictionnary. A Path is a single string or a tuple of string which represente a path in a tree (here a dictionary).</p> <p>We support this operators:</p> Name Alias Parameters Description has Path Check if path exists in context. contains Path, str Check if an attribut path exists and contains specified value. eq <code>==</code> Path, Any Check if an attribut path exists and equals specified value. neq <code>!=</code> Path, Any Check if an attribut path did not exists or not equals specified value. gt <code>&gt;</code> Path, Any Check if an attribut path exists and greather that specified value. lt <code>&lt;</code> Path, Any Check if an attribut path exists and lower that specified value. gte <code>&gt;=</code> Path, Any Check if an attribut path exists and greather or equals that specified value. lte <code>&lt;=</code> Path, Any Check if an attribut path exists and lower or equals that specified value. in <code>:=</code> Path, List[Any] Check if an attribut path exists and attribut value in specified values."},{"location":"#boolean-composition-of-matching-expression","title":"Boolean composition of matching expression","text":"<p>We support this operators:</p> Name Alias Parameters Description and <code>&amp;&amp;</code> list of query And operator. or || list of query Or operator. xor list of query xor operator. nxor list of query nxor operator. not <code>!</code> query Not operator. <p>By default, a list of expressions is equivalent of an \"AND\" of this expressions.</p> <p>Example:</p> <pre><code>{\n    'not': {\n        'has': ['group']\n    },\n    'has': 'application',\n    'eq': [('_link', 'other', 'weight'), 2]\n}\n</code></pre> <p>is equivalent to:</p> <pre><code>{\n    'and': [\n        {\n            'not': [\n                {\n                    'has': ['group']\n                }\n            ]\n        },\n        {\n            'has': ['application']\n        },\n        {\n            'eq': [('_link', 'other', 'weight'), 2]\n        }\n    ]\n}\n</code></pre>"},{"location":"#wished-features","title":"Wished Features","text":"<ul> <li>add projection expression (a return like statement)</li> <li>add join relation ship </li> </ul>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#212","title":"2.1.2","text":"<ul> <li>use uv tool as dependencies manager</li> <li>update github workflow</li> <li>fix few code style issue</li> </ul>"},{"location":"changelog/#211","title":"2.1.1","text":"<ul> <li>remove support for python 3.8</li> </ul>"},{"location":"changelog/#210","title":"2.1.0","text":"<ul> <li> <p>add support for python 3.12</p> </li> <li> <p>build System:</p> </li> <li> <p>update poetry declaration</p> </li> <li>use poe plugin (simplify makefile)</li> <li>use pyright for analysis (remove mypi)</li> </ul>"},{"location":"changelog/#201","title":"2.0.1","text":"<p>Security fix (dev tools)</p> <ul> <li>Removal of e-Tugra root certificate </li> </ul>"},{"location":"changelog/#200","title":"2.0.0","text":"<ul> <li>add support for networkx 3.x:    By default, poetry will try to install the newest version of networkx (<code>networkx = \"*\"</code>).</li> <li>add test pipeline for python 3.9, 3.10 and 3.11</li> </ul>"},{"location":"changelog/#103","title":"1.0.3","text":"<ul> <li>implements <code>search_relationships</code></li> </ul>"},{"location":"changelog/#102","title":"1.0.2","text":"<ul> <li>technical feat:<ul> <li>use ruff as sucessor of flake8</li> <li>update dev dependencies</li> <li>use mkdocs</li> </ul> </li> </ul>"},{"location":"changelog/#101","title":"1.0.1","text":"<ul> <li>fix documentation syntax</li> <li>add search_direct_relationships function</li> <li>rewrote search_edges and search_nodes (avoid extra filter step)</li> </ul>"},{"location":"changelog/#100-2020-05-02","title":"1.0.0 (2020-05-02)","text":"<ul> <li>complete documentation</li> <li>add little example</li> <li>add search_edges, search_nodes for quick and eazy usage</li> <li>complete coverage</li> </ul>"},{"location":"changelog/#010-2020-05-01","title":"0.1.0 (2020-05-01)","text":"<ul> <li>initial project structure based on geronimo-iia/template-python</li> <li>add operator definition, compiler, and parser on node</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jguibert@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>This project is based on Geronimo-iaa's Python Module Template. This is a cookiecutter template for a typical Python library following modern packaging conventions.  It utilizes popular libraries to fully automate all development and deployment tasks.</p>"},{"location":"contributing/#setup","title":"Setup","text":""},{"location":"contributing/#requirements","title":"Requirements","text":"<p>You will need:</p> <ul> <li>Python 3.8\"+</li> <li>Pyenv</li> <li>poetry</li> <li>Make</li> </ul>"},{"location":"contributing/#make-installation","title":"Make Installation","text":"<p>A powerfull tool: * macOS: <code>$ xcode-select --install</code> * Linux: https://www.gnu.org/software/make * Windows: https://mingw.org/download/installer</p>"},{"location":"contributing/#pyenv-installation","title":"Pyenv Installation","text":"<p>Pyenv will manage all our python version. Follow https://github.com/pyenv/pyenv#installation</p>"},{"location":"contributing/#python-installation","title":"Python Installation","text":"<p><code>$ pyenv install 3.8</code></p>"},{"location":"contributing/#poetry-installation-httpspoetryeustaceiodocsinstallation","title":"Poetry Installation: https://poetry.eustace.io/docs/#installation","text":"<p>Poetry will manage our dependencies and create our virtual environment for us.</p>"},{"location":"contributing/#make-target-list","title":"Make Target list","text":"Name Comment make install Install project dependencies make configure Configure poetry make tag Create and push a tag based on current project version. This will launch github release action. make next-patch-version Increment patch version of the project."},{"location":"contributing/#poe-target-list","title":"Poe Target list","text":"Name Comment poetry poe check Run linters and static analysis poetry poe test Run unit tests poetry poe build Builds the source and wheels archives (and run check &amp; test target) poetry poe publish Publishes the package, previously built with the build command, to the remote repository poetry poe docs Builds  site documentation. poetry poe docs-publish Build and publish site documentation. poetry poe clean Delete all generated and temporary files poetry poe requirements Generate requirements.txt <p>You could retrieve those commands with <code>poetry poe</code>. It will output something like this :</p> <pre><code>Poe the Poet - A task runner that works well with poetry.\nversion 0.25.0\n\nResult: No task specified.\n\nUSAGE\n  poetry poe [-h] [-v | -q] [--root PATH] [--ansi | --no-ansi] task [task arguments]\n\nGLOBAL OPTIONS\n  -h, --help     Show this help page and exit\n  --version      Print the version and exit\n  -v, --verbose  Increase command output (repeatable)\n  -q, --quiet    Decrease command output (repeatable)\n  -d, --dry-run  Print the task contents but don't actually run it\n  --root PATH    Specify where to find the pyproject.toml\n  --ansi         Force enable ANSI output\n  --no-ansi      Force disable ANSI output\n\nCONFIGURED TASKS\n  build          Build module\n  publish        Publish module\n  check          Run Linter\n  test           Run unit tests\n  docs           Build site documentation\n  docs-publish   Publish site documentation\n  clean          Remove all generated and temporary files\n  requirements   Generate requirements.txt\n</code></pre>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2020, Jerome Guibert</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>networkx_query</code> project code.</p> <p>networkx-query.</p>"},{"location":"reference/#networkx_query.Evaluator","title":"<code>Evaluator = Callable[[Any], bool]</code>  <code>module-attribute</code>","text":"<p>Predicate function.</p>"},{"location":"reference/#networkx_query.ParserException","title":"<code>ParserException</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Define a parser exception with stack of expression.</p> Source code in <code>networkx_query/definition.py</code> <pre><code>class ParserException(RuntimeError):\n    \"\"\"Define a parser exception with stack of expression.\"\"\"\n\n    def __init__(self, message, stack):\n        super(RuntimeError, self).__init__(message)\n        self.stack = stack\n</code></pre>"},{"location":"reference/#networkx_query.PathCriteria","title":"<code>PathCriteria</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Defines path criteria.</p> Note <p>With <code>target={}, egde=...</code> you could wrote a criteria based on egde constraint only.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Dict</code> <p>target node query constraint. <code>{}</code> means all nodes</p> required <code>edge</code> <code>Dict</code> <p>optional edge query constraint</p> required Source code in <code>networkx_query/relationship.py</code> <pre><code>class PathCriteria(NamedTuple):\n    \"\"\"Defines path criteria.\n\n    Note:\n        With `target={}, egde=...` you could wrote a criteria based on egde constraint only.\n\n    Args:\n        target (Dict): target node query constraint.\n            `{}` means all nodes\n        edge (Dict): optional edge query constraint\n    \"\"\"\n\n    target: Dict\n    edge: Optional[Dict] = None\n</code></pre>"},{"location":"reference/#networkx_query.prepare_query","title":"<code>prepare_query(query)</code>","text":"<p>Transform expression query as a function.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Dict</code> <p>expression query as dictionary</p> required <p>Returns:</p> Type Description <code>Evaluator</code> <p>evaluator function</p> <p>Raises:</p> Type Description <code>ParserException</code> <p>if a parse error occurs</p> Source code in <code>networkx_query/parser.py</code> <pre><code>def prepare_query(query: Dict) -&gt; Evaluator:\n    \"\"\"Transform expression query as a function.\n\n    Arguments:\n        query (Dict): expression query as dictionary\n\n    Returns:\n        (Evaluator): evaluator function\n\n    Exceptions:\n        (ParserException): if a parse error occurs\n\n    \"\"\"\n    return compile_ast(parse(expra=query))\n</code></pre>"},{"location":"reference/#networkx_query.search_direct_relationships","title":"<code>search_direct_relationships(graph, source=None, edge=None, target=None)</code>","text":"<p>Search direct relation ship.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>graph instance</p> required <code>source</code> <code>Optional[Dict]</code> <p>optional source node query constraint</p> <code>None</code> <code>edge</code> <code>Optional[Dict]</code> <p>optional edge query constraint</p> <code>None</code> <code>target</code> <code>Optional[Dict]</code> <p>optional target node query constraint</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Tuple]</code> <p>itrable tuple of edge</p> Source code in <code>networkx_query/relationship.py</code> <pre><code>def search_direct_relationships(\n    graph: Graph, source: Optional[Dict] = None, edge: Optional[Dict] = None, target: Optional[Dict] = None\n) -&gt; Iterable[Tuple]:\n    \"\"\"Search direct relation ship.\n\n    Arguments:\n        graph (Graph): graph instance\n        source (Optional[Dict]): optional source node query constraint\n        edge (Optional[Dict]): optional edge query constraint\n        target (Optional[Dict]): optional target node query constraint\n\n    Returns:\n        (Iterable[Tuple]): itrable tuple of edge\n\n    \"\"\"\n    _iterable = search_edges(graph=graph, query=edge) if edge else graph.edges()\n\n    if source:\n        _predicate_source = prepare_query(source)\n        _iterable = filter(lambda edge: _predicate_source(graph.nodes[edge[0]]), _iterable)\n\n    if target:\n        _predicate_target = prepare_query(target)\n        _iterable = filter(lambda edge: _predicate_target(graph.nodes[edge[1]]), _iterable)\n\n    return _iterable\n</code></pre>"},{"location":"reference/#networkx_query.search_edges","title":"<code>search_edges(graph, query)</code>","text":"<p>Search edges in specified graph which match query.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>networkx graph instance</p> required <code>query</code> <code>Dict</code> <p>query expression</p> required <p>Returns:</p> Type Description <code>Iterable[Tuple]</code> <p>results as an iterable of edge identifier (tuple).</p> <p>Raises:</p> Type Description <code>ParserException</code> <p>if a parse error occurs</p> Source code in <code>networkx_query/query.py</code> <pre><code>def search_edges(graph: Graph, query: Dict) -&gt; Iterable[Tuple]:\n    \"\"\"Search edges in specified graph which match query.\n\n    Arguments:\n        graph (Graph): networkx graph instance\n        query (Dict): query expression\n\n    Returns:\n        (Iterable[Tuple]): results as an iterable of edge identifier (tuple).\n\n    Exceptions:\n        (ParserException): if a parse error occurs\n\n    \"\"\"\n    _predicate = prepare_query(query)\n    return map(get_two_first_items, filter(lambda edge: _predicate(edge[2]), graph.edges(data=True)))\n</code></pre>"},{"location":"reference/#networkx_query.search_nodes","title":"<code>search_nodes(graph, query)</code>","text":"<p>Search nodes in specified graph which match query.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>networkx graph instance</p> required <code>query</code> <code>Dict</code> <p>query expression</p> required <p>Returns:</p> Type Description <code>Iterable[Any]</code> <p>results as an iterable of node identifier.</p> <p>Raises:</p> Type Description <code>ParserException</code> <p>if a parse error occurs</p> Source code in <code>networkx_query/query.py</code> <pre><code>def search_nodes(graph: Graph, query: Dict) -&gt; Iterable[Any]:\n    \"\"\"Search nodes in specified graph which match query.\n\n    Arguments:\n        graph (Graph): networkx graph instance\n        query (Dict): query expression\n\n    Returns:\n        (Iterable[Any]): results as an iterable of node identifier.\n\n    Exceptions:\n        (ParserException): if a parse error occurs\n\n    \"\"\"\n    _predicate = prepare_query(query)\n    return map(get_first_item, filter(lambda node: _predicate(node[1]), graph.nodes(data=True)))\n</code></pre>"},{"location":"reference/#networkx_query.search_relationships","title":"<code>search_relationships(graph, source, *nodes)</code>","text":"<p>Search all valid path according specified template.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>graph instance</p> required <code>source</code> <code>Dict</code> <p>source node query constraint</p> required <code>nodes</code> <code>PathCriteria</code> <p>ordered list of path criteria</p> <code>()</code> <p>Returns:</p> Type Description <code>Iterable[Tuple]</code> <p>all path which validate specification</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a path criteria have no constraint</p> Source code in <code>networkx_query/relationship.py</code> <pre><code>def search_relationships(graph: Graph, source: Dict, *nodes: PathCriteria) -&gt; Iterable[List]:\n    \"\"\"Search all valid path according specified template.\n\n    Args:\n        graph (Graph): graph instance\n        source (Dict): source node query constraint\n        nodes (PathCriteria): ordered list of path criteria\n\n    Returns:\n        (Iterable[Tuple]): all path which validate specification\n\n    Raises:\n        (RuntimeError): if a path criteria have no constraint\n    \"\"\"\n\n    if not nodes:\n        # cast single edge to path\n        for a, b in search_direct_relationships(graph=graph, source=source):\n            yield [a, b]\n        return\n\n    # Validate path template\n    node_count = len(nodes)\n    assert node_count &gt;= 1\n\n    # build pair of relations ships\n    relationships = []\n\n    for i in range(node_count):\n        item = set(\n            search_direct_relationships(\n                graph=graph,\n                source=source if i == 0 else nodes[i - 1].target,\n                edge=nodes[i].edge,\n                target=nodes[i].target,\n            )\n        )\n        relationships.append(item)\n\n        if not len(item):\n            raise RuntimeError(f\"No valid path from {i}th criteria.\")\n\n    # recursive\n    def visit(path, node, i):\n        for a, b in filter(lambda t: t[0] == node, relationships[i]):\n            if i + 1 &lt; node_count:\n                yield from visit(path=path + [a], node=b, i=i + 1)\n            else:\n                yield path + [a, b]\n\n    for a, b in relationships[0]:\n        if node_count == 1:\n            yield [a, b]\n        else:\n            yield from visit(path=[a], node=b, i=1)\n</code></pre>"}]}